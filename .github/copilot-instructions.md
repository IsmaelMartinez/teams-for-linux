# GitHub Copilot Instructions for Teams for Linux

## Project Overview

Teams for Linux is an Electron-based desktop application that wraps Microsoft Teams web app for Linux users. The app provides a native desktop experience with additional features like custom CSS, backgrounds, notifications, and system integration.

## Architecture & Key Components

### Main Application Structure

- **Entry Point**: `app/index.js` - Main Electron process with app lifecycle management
- **Configuration**: `app/appConfiguration/` - Centralized config management using electron-store
- **Main Window**: `app/mainAppWindow/` - BrowserWindow management and Teams web app wrapper
- **Browser Tools**: `app/browser/tools/` - Client-side scripts injected into Teams web interface

### Key Modules

- **Notifications**: `app/browser/notifications/` - Activity tracking and desktop notifications
- **Cache Management**: `app/cacheManager/` - Automatic cache cleanup to prevent OAuth token corruption
- **Custom Features**:
  - `app/customCSS/` - User-defined styling injection
  - `app/customBackground/` - Custom Teams background support
  - `app/spellCheckProvider/` - Multi-language spell checking
- **System Integration**:
  - `app/menus/` - Application and tray menus
  - `app/connectionManager/` - Network connection handling
  - `app/certificate/` - SSL certificate management
  - `app/incomingCallToast/` - Custom toast for incoming calls
  - `app/streamSelector/` - Stream selection for screen sharing

## Development Patterns

### Configuration Management

```javascript
// All config through AppConfiguration class
const { AppConfiguration } = require("./appConfiguration");
const appConfig = new AppConfiguration(
  app.getPath("userData"),
  app.getVersion()
);
```

### Browser Script Injection

- Scripts in `app/browser/tools/` are injected into Teams web interface
- Use `window.addEventListener('DOMContentLoaded')` pattern for DOM manipulation
- Follow existing patterns in `reactHandler.js` and `settings.js`

### Event Communication

- Main process ↔ Renderer: Standard Electron IPC patterns
- Browser scripts ↔ Main: Custom event dispatching through DOM events

## Build & Development

### Key Commands

```bash
npm start              # Development mode with trace warnings
npm run lint          # ESLint validation
npm run dist:linux    # Build Linux packages (AppImage, deb, rpm, snap)
npm run pack          # Development build without packaging
```

### Build Configuration

- **electron-builder** config in `package.json` under `"build"` section
- Platform-specific builds: Linux (primary), macOS, Windows
- Multiple output formats: AppImage, deb, rpm, snap, tar.gz

### Release Process

- Automated via GitHub Actions (`.github/workflows/build.yml`)
- Version managed in `package.json` and propagated to build metadata
- Release info generated by `scripts/generateReleaseInfo.js`
- Debian changelog generated by `scripts/generateDebianChangelog.js` for proper package management

## Testing & Quality

- **Linting**: ESLint with custom config (`eslint.config.mjs`)
- **Security**: Snyk integration for vulnerability scanning
- **Code Quality**: SonarCloud integration
- **CI/CD**: GitHub Actions for build validation and releases

## Common Patterns

- **Single Instance**: The application ensures only a single instance is running using `app.requestSingleInstanceLock()`.
- **Command Line Switches**: Various command-line switches are appended (e.g., for Wayland/PipeWire, proxy settings, disabling GPU, and custom Electron CLI flags from config).
- Use `electron-log` for logging throughout the application
- Configuration changes require app restart (document this in features)
- Browser scripts should be defensive against Teams web app changes
- Follow existing error handling patterns in main modules

## External Dependencies

- **Core**: Electron, electron-builder for packaging
- **System**: @homebridge/dbus-native for Linux desktop integration
- **Storage**: electron-store for persistent configuration
- **Audio**: node-sound for notification sounds (optional dependency)

When working on this codebase, always consider cross-platform compatibility and the fact that the Teams web interface can change independently of this application.
