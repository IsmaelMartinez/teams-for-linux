name: Issue Triage Bot

# Analyzes new bug reports for missing information, suggests solutions from
# the troubleshooting guide, and detects potential duplicate issues.
# Posts a single consolidated comment per issue.
# Phase 1: Missing info detection (v2.7.4)
# Phase 2: AI-powered solution suggestions via Gemini 2.5 Flash
# Phase 3: Duplicate detection against issue index via Gemini 2.5 Flash
# See: docs-site/docs/development/research/github-issue-bot-investigation.md

on:
  issues:
    types: [opened]

# Restrict default permissions â€” each job declares only what it needs
permissions: {}

jobs:
  triage-and-suggest:
    runs-on: ubuntu-latest
    # Only run for issues labeled as bugs
    if: contains(github.event.issue.labels.*.name, 'bug')
    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          sparse-checkout: |
            .github/issue-bot/troubleshooting-index.json
            .github/issue-bot/issue-index.json
          sparse-checkout-cone-mode: false

      - name: Phase 1 - Analyze missing information
        id: phase1
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const issueBody = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';
            const issueUser = context.payload.issue.user.login;

            // Skip bot accounts
            if (issueUser.includes('[bot]') || issueUser.endsWith('-bot')) {
              console.log('Skipping bot account');
              core.setOutput('skip', 'true');
              return;
            }

            // Safety: check if bot already commented on this issue
            const { data: comments } =
              await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

            const BOT_SIGNATURE =
              "I'm a bot that helps with issue triage";
            if (
              comments.some(
                (c) =>
                  c.user.type === 'Bot' &&
                  c.body.includes(BOT_SIGNATURE)
              )
            ) {
              console.log('Bot already commented on this issue. Skipping.');
              core.setOutput('skip', 'true');
              return;
            }

            core.setOutput('skip', 'false');

            // --- Section Parser ---
            // GitHub issue forms produce markdown with ### headers for each field.
            function getSection(body, header) {
              const escaped = header.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(
                `### ${escaped}\\s*\\n([\\s\\S]*?)(?=\\n### |$)`
              );
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            }

            // --- Content Analysis Helpers ---
            function stripFences(text) {
              return text.replace(/`{3,}[\w]*\n?/g, '').trim();
            }

            function isDefaultStepsTemplate(content) {
              if (!content || content === '_No response_') return true;
              const cleaned = stripFences(content);
              if (!cleaned) return true;
              const withoutMarkers = cleaned
                .replace(/^\s*\d+\.\s*/gm, '')
                .replace(/\.\.\./g, '')
                .trim();
              return withoutMarkers.length === 0;
            }

            function isDebugMissing(content) {
              if (!content || content === '_No response_') return true;
              const cleaned = stripFences(content);
              if (!cleaned) return true;
              const withoutDefaults = cleaned
                .replace(/^bash\s*$/gm, '')
                .replace(/^markdown\s*$/gm, '')
                .replace(
                  /ELECTRON_ENABLE_LOGGING=true\s+teams-for-linux\s+--logConfig='[^']*'/g,
                  ''
                )
                .trim();
              return withoutDefaults.length === 0;
            }

            // --- Extract and Analyze Sections ---
            const canReproduce = getSection(
              issueBody,
              'Can you reproduce this bug in the website/PWA?'
            );
            const reproSteps = getSection(issueBody, 'Reproduction steps');
            const expectedBehavior = getSection(issueBody, 'Expected Behavior');
            const debugOutput = getSection(issueBody, 'Debug');

            const missingItems = [];

            if (isDefaultStepsTemplate(reproSteps)) {
              missingItems.push({
                label: 'Reproduction steps',
                detail:
                  'Step-by-step instructions to trigger the bug (the more specific, the faster we can investigate)',
              });
            }

            if (isDebugMissing(debugOutput)) {
              missingItems.push({
                label: 'Debug console output',
                detail:
                  'Log output from running the application with debug logging enabled',
              });
            }

            if (isDefaultStepsTemplate(expectedBehavior)) {
              missingItems.push({
                label: 'Expected behavior',
                detail:
                  'A description of what you expected to happen instead',
              });
            }

            const isPwaReproducible =
              canReproduce.toLowerCase().includes('yes');

            core.setOutput('missing_items_json', JSON.stringify(missingItems));
            core.setOutput('is_pwa_reproducible', isPwaReproducible.toString());
            core.setOutput('issue_title', issueTitle.substring(0, 200));
            core.setOutput('issue_body_truncated', issueBody.substring(0, 2000));

            console.log(`Phase 1: ${missingItems.length} missing items, PWA reproducible: ${isPwaReproducible}`);

      - name: Phase 2 - Suggest solutions from documentation
        id: phase2
        if: steps.phase1.outputs.skip != 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ steps.phase1.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.phase1.outputs.issue_body_truncated }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Skip if Gemini API key is not configured (forks)
            if (!process.env.GEMINI_API_KEY) {
              console.log('GEMINI_API_KEY not configured, skipping Phase 2');
              core.setOutput('suggestions_json', '[]');
              return;
            }

            // Read pre-processed troubleshooting index
            const indexPath = path.join(
              process.env.GITHUB_WORKSPACE,
              '.github',
              'issue-bot',
              'troubleshooting-index.json'
            );

            let sections;
            try {
              sections = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
            } catch (e) {
              console.log('Could not read troubleshooting index, skipping Phase 2');
              core.setOutput('suggestions_json', '[]');
              return;
            }

            // Use environment variables for untrusted input (avoids injection)
            const issueTitle = (process.env.ISSUE_TITLE || '').substring(0, 200);
            const issueBody = (process.env.ISSUE_BODY || '')
              .replace(/```[\s\S]*?```/g, '')
              .substring(0, 1500);

            // Build compact section summaries for the prompt
            const sectionSummaries = sections
              .map(
                (s, i) =>
                  `[${i}] ${s.title} (${s.category}): ${s.description.substring(0, 150)}`
              )
              .join('\n');

            const prompt = `You are a helpful assistant for the "Teams for Linux" open source project.
            Match this bug report against known issues from our documentation.

            KNOWN ISSUES:
            ${sectionSummaries}

            BUG REPORT:
            Title: ${issueTitle}
            Body: ${issueBody}

            Return a JSON array of 0-3 matches. Only include sections with a meaningful connection (shared symptoms, similar error, same component). Use humble language in the reason field ("appears similar", "might be related", "could be connected").

            Format: [{"index": 0, "reason": "This appears similar because...", "actionable_step": "Try clearing the cache..."}]

            If no sections match, return: []
            Respond with ONLY valid JSON, no other text.`;

            try {
              const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                      temperature: 0.3,
                      maxOutputTokens: 500,
                    },
                  }),
                }
              );

              if (!response.ok) {
                console.log(`Gemini API returned ${response.status}, skipping suggestions`);
                core.setOutput('suggestions_json', '[]');
                return;
              }

              const data = await response.json();
              const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '[]';

              // Extract JSON from response (handle markdown code fences)
              const jsonMatch = rawText.match(/\[[\s\S]*\]/);
              if (!jsonMatch) {
                console.log('No valid JSON array in Gemini response');
                core.setOutput('suggestions_json', '[]');
                return;
              }

              const suggestions = JSON.parse(jsonMatch[0]);

              // Validate structure and bounds
              const validated = suggestions
                .filter(
                  (s) =>
                    typeof s.index === 'number' &&
                    s.index >= 0 &&
                    s.index < sections.length &&
                    typeof s.reason === 'string' &&
                    typeof s.actionable_step === 'string'
                )
                .slice(0, 3)
                .map((s) => ({
                  index: s.index,
                  title: sections[s.index].title,
                  docUrl: sections[s.index].docUrl,
                  reason: s.reason.substring(0, 200),
                  actionable_step: s.actionable_step.substring(0, 200),
                }));

              core.setOutput('suggestions_json', JSON.stringify(validated));
              console.log(`Phase 2: ${validated.length} matching documentation sections`);
            } catch (error) {
              console.log('Gemini API unavailable, posting without suggestions');
              core.setOutput('suggestions_json', '[]');
            }

      - name: Phase 3 - Detect potential duplicates
        id: phase3
        if: steps.phase1.outputs.skip != 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ steps.phase1.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.phase1.outputs.issue_body_truncated }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Skip if Gemini API key is not configured (forks)
            if (!process.env.GEMINI_API_KEY) {
              console.log('GEMINI_API_KEY not configured, skipping Phase 3');
              core.setOutput('duplicates_json', '[]');
              return;
            }

            // Read pre-processed issue index
            const indexPath = path.join(
              process.env.GITHUB_WORKSPACE,
              '.github',
              'issue-bot',
              'issue-index.json'
            );

            let issues;
            try {
              issues = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
            } catch (e) {
              console.log('Could not read issue index, skipping Phase 3');
              core.setOutput('duplicates_json', '[]');
              return;
            }

            const currentIssueNumber = parseInt(process.env.ISSUE_NUMBER, 10);

            // Filter out the current issue from candidates
            const candidates = issues.filter(
              (i) => i.number !== currentIssueNumber
            );

            if (candidates.length === 0) {
              console.log('No candidate issues in index');
              core.setOutput('duplicates_json', '[]');
              return;
            }

            // Use environment variables for untrusted input (avoids injection)
            const issueTitle = (process.env.ISSUE_TITLE || '').substring(0, 200);
            const issueBody = (process.env.ISSUE_BODY || '')
              .replace(/```[\s\S]*?```/g, '')
              .substring(0, 1500);

            // Build compact issue summaries for the prompt
            const issueSummaries = candidates
              .map(
                (issue) =>
                  `[#${issue.number}] (${issue.state}) ${issue.title}: ${(issue.summary || '').substring(0, 120)}`
              )
              .join('\n');

            const prompt = `You are a helpful assistant for the "Teams for Linux" open source project.
            Compare this new issue against existing issues to find potential duplicates or closely related reports.

            EXISTING ISSUES:
            ${issueSummaries}

            NEW ISSUE:
            Title: ${issueTitle}
            Body: ${issueBody}

            Return a JSON array of 0-3 matches. Only include issues with a strong semantic connection (same bug, same feature request, clearly overlapping symptoms). Use humble language in the reason field ("might be related", "appears similar", "could be the same issue").

            For each match, estimate a similarity percentage (60-95). Only include matches above 60%.

            Format: [{"number": 123, "reason": "This might be related because...", "similarity": 75}]

            If no issues are similar, return: []
            Respond with ONLY valid JSON, no other text.`;

            try {
              const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                      temperature: 0.2,
                      maxOutputTokens: 400,
                    },
                  }),
                }
              );

              if (!response.ok) {
                console.log(`Gemini API returned ${response.status}, skipping duplicates`);
                core.setOutput('duplicates_json', '[]');
                return;
              }

              const data = await response.json();
              const rawText =
                data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '[]';

              // Extract JSON from response (handle markdown code fences)
              const jsonMatch = rawText.match(/\[[\s\S]*\]/);
              if (!jsonMatch) {
                console.log('No valid JSON array in Gemini response');
                core.setOutput('duplicates_json', '[]');
                return;
              }

              const duplicates = JSON.parse(jsonMatch[0]);

              // Validate structure and bounds
              const issueNumbers = new Set(candidates.map((i) => i.number));
              const validated = duplicates
                .filter(
                  (d) =>
                    typeof d.number === 'number' &&
                    issueNumbers.has(d.number) &&
                    typeof d.reason === 'string' &&
                    typeof d.similarity === 'number' &&
                    d.similarity >= 60 &&
                    d.similarity <= 100
                )
                .slice(0, 3)
                .map((d) => {
                  const issue = candidates.find(
                    (i) => i.number === d.number
                  );
                  return {
                    number: d.number,
                    title: issue.title,
                    state: issue.state,
                    reason: d.reason.substring(0, 200),
                    similarity: Math.round(d.similarity),
                    closed_at: issue.closed_at || null,
                    milestone: issue.milestone || null,
                  };
                });

              core.setOutput('duplicates_json', JSON.stringify(validated));
              console.log(
                `Phase 3: ${validated.length} potential duplicates found`
              );
            } catch (error) {
              console.log(
                'Gemini API unavailable, posting without duplicate suggestions'
              );
              core.setOutput('duplicates_json', '[]');
            }

      - name: Post consolidated comment
        if: steps.phase1.outputs.skip != 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          MISSING_ITEMS_JSON: ${{ steps.phase1.outputs.missing_items_json }}
          IS_PWA_REPRODUCIBLE: ${{ steps.phase1.outputs.is_pwa_reproducible }}
          SUGGESTIONS_JSON: ${{ steps.phase2.outputs.suggestions_json }}
          DUPLICATES_JSON: ${{ steps.phase3.outputs.duplicates_json }}
        with:
          script: |
            const missingItems = JSON.parse(process.env.MISSING_ITEMS_JSON || '[]');
            const isPwaReproducible = process.env.IS_PWA_REPRODUCIBLE === 'true';
            const suggestions = JSON.parse(process.env.SUGGESTIONS_JSON || '[]');
            const duplicates = JSON.parse(process.env.DUPLICATES_JSON || '[]');

            // Skip if nothing to report
            if (
              missingItems.length === 0 &&
              !isPwaReproducible &&
              suggestions.length === 0 &&
              duplicates.length === 0
            ) {
              console.log('Nothing to report. No comment needed.');
              return;
            }

            const parts = [];

            parts.push('ðŸ‘‹ Thanks for reporting this issue!\n');

            // PWA reproducibility note
            if (isPwaReproducible) {
              parts.push(
                '> **Note:** You mentioned this bug can also be reproduced in the Teams website/PWA. ' +
                  'This might indicate the issue is with the Teams web app itself rather than Teams for Linux. ' +
                  'You could also report it to [Microsoft](https://feedbackportal.microsoft.com/). ' +
                  "That said, we'll still take a look â€” there may be something we can do on our end.\n"
              );
            }

            // Solution suggestions from Phase 2
            if (suggestions.length > 0) {
              parts.push('**This might be related to a known issue:**\n');
              for (const s of suggestions) {
                parts.push(
                  `- [${s.title}](${s.docUrl}) â€” ${s.reason} ${s.actionable_step}\n`
                );
              }
              parts.push(
                '> These suggestions are based on our documentation and may not be exact matches.\n'
              );
            }

            // Duplicate suggestions from Phase 3
            if (duplicates.length > 0) {
              const openDups = duplicates.filter(
                (d) => d.state === 'open'
              );
              const closedDups = duplicates.filter(
                (d) => d.state === 'closed'
              );

              parts.push(
                '**This issue might be related to existing discussions:**\n'
              );

              if (openDups.length > 0) {
                parts.push('*Potentially related open issues:*');
                for (const d of openDups) {
                  parts.push(
                    `- #${d.number} â€” "${d.title}" (${d.similarity}% similar) â€” ${d.reason}`
                  );
                }
                parts.push('');
              }

              if (closedDups.length > 0) {
                parts.push(
                  '*Recently resolved issues that could be relevant:*'
                );
                for (const d of closedDups) {
                  const resolvedNote = d.milestone
                    ? `Resolved in ${d.milestone}`
                    : 'Resolved';
                  parts.push(
                    `- #${d.number} â€” "${d.title}" (${resolvedNote}) â€” ${d.reason}`
                  );
                }
                parts.push('');
              }

              parts.push(
                '> If one of these matches your issue, consider adding your details there instead.\n'
              );
            }

            // Missing information checklist
            if (missingItems.length > 0) {
              parts.push(
                'To help us investigate, could you provide some additional details?\n'
              );
              parts.push('**Missing information:**');
              for (const item of missingItems) {
                parts.push(
                  `- [ ] **${item.label}** â€” ${item.detail}`
                );
              }
              parts.push('');
            }

            // Debug instructions (collapsible)
            if (
              missingItems.some(
                (i) => i.label === 'Debug console output'
              )
            ) {
              parts.push(
                '<details>\n' +
                  '<summary><b>How to get debug logs</b></summary>\n\n' +
                  '1. Run the application from the terminal with logging enabled:\n' +
                  '   ```bash\n' +
                  "   ELECTRON_ENABLE_LOGGING=true teams-for-linux --logConfig='{\"transports\":{\"console\":{\"level\":\"debug\"}}}'\n" +
                  '   ```\n' +
                  '2. Reproduce the issue\n' +
                  '3. Copy the relevant console output\n' +
                  '4. Feel free to redact any sensitive information (emails, URLs, etc.)\n\n' +
                  '</details>\n'
              );
            }

            // Troubleshooting guide link
            parts.push(
              '> **Tip:** You might also find helpful information in our ' +
                '[Troubleshooting Guide](https://ismaelmartinez.github.io/teams-for-linux/troubleshooting).\n'
            );

            // Bot disclosure
            parts.push('---\n');
            parts.push(
              "*I'm a bot that helps with issue triage. " +
                'Suggestions are based on documentation and may not be exact. ' +
                'A maintainer will review this issue.*'
            );

            const commentBody = parts.join('\n');

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody,
            });

            console.log(
              `Posted comment (${missingItems.length} missing items, ${suggestions.length} suggestions, ${duplicates.length} duplicates, PWA: ${isPwaReproducible})`
            );
