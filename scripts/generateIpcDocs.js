#!/usr/bin/env node

/**
 * IPC Documentation Generator
 *
 * Automatically scans the codebase for all IPC channel registrations
 * (ipcMain.handle and ipcMain.on) and generates documentation.
 *
 * Usage: node scripts/generateIpcDocs.js
 */

const fs = require('node:fs');
const path = require('node:path');
const { execSync } = require('node:child_process');

const APP_DIR = path.join(__dirname, '..', 'app');
const DOCS_OUTPUT = path.join(__dirname, '..', 'docs-site', 'docs', 'development', 'ipc-api-generated.md');

// IPC channel categories based on file location
const CATEGORIES = {
  'app/index.js': 'Core Application',
  'app/notifications/': 'Notifications',
  'app/screenSharing/': 'Screen Sharing',
  'app/idle/': 'Idle Monitoring',
  'app/partitions/': 'Partitions & Zoom',
  'app/menus/': 'Menus & Tray',
  'app/customBackground/': 'Custom Background',
  'app/mainAppWindow/': 'Main Window',
  'app/login/': 'Authentication',
  'app/connectionManager/': 'Connection Management',
  'app/incomingCallToast/': 'Incoming Calls',
};

function findCategory(filePath) {
  for (const [pattern, category] of Object.entries(CATEGORIES)) {
    if (filePath.includes(pattern)) {
      return category;
    }
  }
  return 'Other';
}

function extractIpcChannels() {
  console.log('Scanning for IPC channels...');

  // Use ripgrep to find all IPC registrations
  const grepCommand = `rg -n "ipcMain\\.(handle|on)\\(" --type js ${APP_DIR}`;

  let output;
  try {
    output = execSync(grepCommand, { encoding: 'utf8' });
  } catch (error) {
    console.error('Error running ripgrep:', error.message);
    process.exit(1);
  }

  const channels = [];
  const lines = output.trim().split('\n');

  for (const line of lines) {
    // Parse the ripgrep output: filename:lineNumber:content
    const match = line.match(/^([^:]+):(\d+):(.+)$/);
    if (!match) continue;

    const [, filePath, lineNumber, content] = match;

    // Extract channel name and type
    const channelMatch = content.match(/ipcMain\.(handle|on)\(\s*["']([^"']+)["']/);
    if (!channelMatch) continue;

    const [, type, channelName] = channelMatch;

    // Read the file to get context (comments, function signature)
    const fullPath = path.resolve(filePath);
    const relativePath = path.relative(path.join(__dirname, '..'), fullPath);
    const fileContent = fs.readFileSync(fullPath, 'utf8');
    const fileLines = fileContent.split('\n');
    const lineIndex = parseInt(lineNumber) - 1;

    // Look for JSDoc or inline comments above the line
    let description = '';
    for (let i = lineIndex - 1; i >= Math.max(0, lineIndex - 5); i--) {
      const prevLine = fileLines[i].trim();
      if (prevLine.startsWith('//')) {
        description = prevLine.replace('//', '').trim() + ' ' + description;
      } else if (prevLine.startsWith('*')) {
        description = prevLine.replace(/^\*\s*/, '').trim() + ' ' + description;
      } else if (prevLine && !prevLine.startsWith('/*')) {
        break;
      }
    }

    if (!description) {
      description = 'No description available';
    }

    channels.push({
      name: channelName,
      type: type === 'handle' ? 'Request/Response' : 'Event',
      category: findCategory(relativePath),
      file: relativePath,
      lineNumber: lineNumber,
      description: description.trim() || 'No description available',
    });
  }

  return channels;
}

function generateMarkdown(channels) {
  // Group channels by category
  const channelsByCategory = {};
  for (const channel of channels) {
    if (!channelsByCategory[channel.category]) {
      channelsByCategory[channel.category] = [];
    }
    channelsByCategory[channel.category].push(channel);
  }

  // Sort categories
  const sortedCategories = Object.keys(channelsByCategory).sort();

  let markdown = `# IPC API Reference (Auto-Generated)

> **Note**: This file is auto-generated by \`scripts/generateIpcDocs.js\`. Do not edit manually.
>
> **Last Generated**: ${new Date().toISOString()}

## Overview

This document lists all IPC (Inter-Process Communication) channels registered in the application.

- **Request/Response** channels use \`ipcMain.handle()\` and expect a return value
- **Event** channels use \`ipcMain.on()\` for fire-and-forget notifications

**Total Channels**: ${channels.length}

---

`;

  for (const category of sortedCategories) {
    const categoryChannels = channelsByCategory[category];

    markdown += `## ${category}\n\n`;
    markdown += `| Channel | Type | Description | Location |\n`;
    markdown += `|---------|------|-------------|----------|\n`;

    for (const channel of categoryChannels.sort((a, b) => a.name.localeCompare(b.name))) {
      const location = `[\`${channel.file}:${channel.lineNumber}\`](/${channel.file}#L${channel.lineNumber})`;
      markdown += `| \`${channel.name}\` | ${channel.type} | ${channel.description} | ${location} |\n`;
    }

    markdown += '\n';
  }

  markdown += `---

## Channel Security

All IPC channels are validated through the security layer in \`app/security/ipcValidator.js\`.
See the [IPC Security documentation](../../security.md#ipc-security) for more information.

## Adding New Channels

When adding a new IPC channel:

1. Register the channel with \`ipcMain.handle()\` or \`ipcMain.on()\`
2. Add the channel to the allowlist in \`app/security/ipcValidator.js\`
3. Add a comment above the registration describing its purpose
4. Run \`npm run generate-ipc-docs\` to update this documentation

---

*Generated by \`scripts/generateIpcDocs.js\`*
`;

  return markdown;
}

function main() {
  console.log('IPC Documentation Generator');
  console.log('============================\n');

  const channels = extractIpcChannels();
  console.log(`Found ${channels.length} IPC channels\n`);

  const markdown = generateMarkdown(channels);

  // Ensure output directory exists
  const outputDir = path.dirname(DOCS_OUTPUT);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(DOCS_OUTPUT, markdown, 'utf8');
  console.log(`âœ… Documentation generated: ${DOCS_OUTPUT}`);

  // Also output a summary to console
  console.log('\nChannel Summary:');
  const categories = {};
  for (const channel of channels) {
    categories[channel.category] = (categories[channel.category] || 0) + 1;
  }

  for (const [category, count] of Object.entries(categories).sort()) {
    console.log(`  ${category}: ${count} channels`);
  }
}

main();
